
events {
}

http {
    # NGINX performs its own name resolution, and we need to tell it how to do that.
    # 
    # We want this service to be able to route requests to apps on apps.internal, so we will use
    # the first resolver defined for the container in which the app is running.
    # 
    # We do this by populating the NAMESERVER environment variable at startup time. See the code in 
    # .profile for how this is done. NOTE: In future, we should be able to use a feature native 
    # to the buildpack to do this: https://github.com/cloudfoundry/nginx-buildpack/pull/12
    # 
    # We know that Cloud Foundry's internal ipv6 routing is immature, so we'll also opt to only 
    # do ipv4 resolution.
    resolver {{env "NAMESERVER"}} ipv6=off;   

    # Set up variables we'll use later
    map $http_upgrade $connection_upgrade {
      default upgrade;
      ''      close;
    }

    server {
        # Bind to the Cloud Foundry-provided HTTP port
        listen {{port}} default_server;
        absolute_redirect off;
        port_in_redirect off;

        error_log error.log debug;

        # Ensure any path with just one element ends with a slash
        rewrite ^/([^/]+)$ $1/ redirect;

        # Match any request with a path, and note the initial element in $subpath
        location ~* ^/(?<subpath>[^/]+)(?<subsubpath>.*) {
            
            # Proxy $subpath.apps.internal (internal apps only serve on port 8080)
            proxy_pass $scheme://$subpath.apps.internal:8080$subsubpath;
            proxy_redirect $scheme://$subpath.apps.internal:8080$subsubpath $scheme://$host/$subpath$subsubpath;

            # Ensure we properly support WebSocket connection upgrades and keepalives.
            # From https://support.rstudio.com/hc/en-us/articles/213733868-Running-Shiny-Server-with-a-Proxy
            proxy_http_version 1.1;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Upgrade $http_upgrade;
            proxy_read_timeout 20d;
            proxy_buffering off;
        }   

        # Defines a simple status page that can be used as a health-check for this proxy, 
        # rather than making requests to an upstream.
        location = /nginx_status/ {
            stub_status on;

            access_log on;
            allow all;
        }
    }
}
